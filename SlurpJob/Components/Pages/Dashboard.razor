@page "/"
@using SlurpJob.Components
@using SlurpJob.Services
@using SlurpJob.Data
@using SlurpJob.Models
@using Microsoft.EntityFrameworkCore
@inject SlurpJob.Services.IngestionService Ingestion
@inject IJSRuntime JS
@inject IDbContextFactory<SlurpContext> DbFactory
@implements IDisposable

<PageTitle>Dashboard</PageTitle>

<div class="dashboard-container">
    <div class="dashboard-header">
        <div class="brand">SLURPJOB</div>
        <div class="stats">
            <div class="stat-item">
                <span class="label">EVENTS</span>
                <span class="value">@Ingestion.TotalEvents.ToString("N0")</span>
            </div>
            <div class="stat-item">
                <span class="label">THREATS</span>
                <span class="value" style="color: #ff4444">@Ingestion.ThreatsDetected.ToString("N0")</span>
            </div>
             <div class="stat-item">
                <span class="label">CPS</span>
                <span class="value">@((int)Ingestion.EventsPerSecond)</span>
            </div>
        </div>
    </div>

    <div class="dashboard-top">
        <div class="map-wrapper">
             <canvas id="mapViz"></canvas>
        </div>
        <div class="timeline-wrapper">
             <div class="timeline-controls">
                <button class="@(_currentTimeRange == "1H" ? "active" : "")" @onclick='() => SetTimeRange("1H")'>1H</button>
                <button class="@(_currentTimeRange == "1D" ? "active" : "")" @onclick='() => SetTimeRange("1D")'>1D</button>
                <button class="@(_currentTimeRange == "1W" ? "active" : "")" @onclick='() => SetTimeRange("1W")'>1W</button>
                <button class="@(_currentTimeRange == "1M" ? "active" : "")" @onclick='() => SetTimeRange("1M")'>1M</button>
             </div>
             <canvas id="timelineChart"></canvas>
        </div>
    </div>

    <div class="dashboard-bottom">
         <LiveFeed OnEventSelected="ShowPayload" />
    </div>
</div>

<PayloadInspector @ref="_payloadInspector" />

@code {
    private PayloadInspector _payloadInspector = default!;
    private System.Threading.Timer? _refreshTimer;
    private Dictionary<string, int> _countryCounts = new();
    private string _currentTimeRange = "1H";

    protected override void OnInitialized()
    {
        Ingestion.OnNewIncident += OnIncidentReceived;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try {
                // Initialize Globe and Timeline
                // Use catch to ensure one failure doesn't stop the other
                try { await JS.InvokeVoidAsync("slurpMap2D.init", "mapViz"); } catch(Exception ex) { Console.WriteLine("Map2D Init: " + ex.Message); }
                try { await JS.InvokeVoidAsync("slurpTimeline.init", "timelineChart", DotNetObjectReference.Create(this)); } catch(Exception ex) { Console.WriteLine("Timeline Init: " + ex.Message); }
                
                // Load historical country counts from database
                await LoadHistoricalCountryCounts();
            } catch (Exception ex) {
                Console.WriteLine("JS Init Failed: " + ex.Message);
            }
            
            // Start Refresh Timer for stats and timeline
            _refreshTimer = new System.Threading.Timer(async _ => 
            {
                await InvokeAsync(StateHasChanged);
                try {
                    await JS.InvokeVoidAsync("slurpTimeline.update", "timelineChart");
                } catch { }
            }, null, 1000, 5000); // Update timeline every 5s
        }
    }

    private void OnIncidentReceived(IncidentLog incident)
    {
        if (string.IsNullOrEmpty(incident.CountryCode)) return;

        InvokeAsync(async () =>
        {
            if (!_countryCounts.ContainsKey(incident.CountryCode))
            {
                _countryCounts[incident.CountryCode] = 0;
            }
            _countryCounts[incident.CountryCode]++;

            // Push update to the map
            // We use Fire-and-Forget for performance, or await if we want to ensure order.
            // Since this runs within InvokeAsync, awaiting is fine.
            try
            {
                await JS.InvokeVoidAsync("slurpMap2D.updateHeatmap", _countryCounts);
            }
            catch (Exception ex)
            {
                // If the user navigates away, JS interop might fail.
                Console.WriteLine($"Map Update Error: {ex.Message}");
            }
            
            // Note: We don't call StateHasChanged here for every single packet to avoid UI thrashing.
            // The stats counters are updated by the _refreshTimer every 1s.
            // The LiveFeed component handles its own updates via its own subscription if needed, 
            // or if it binds to a list that updates. 
            // (Assuming LiveFeed has its own logic or receives this event).
            // Actually, looking at LiveFeed usage: <LiveFeed OnEventSelected="ShowPayload" />
            // It seems LiveFeed might handle its own data fetching. 
            // But for THIS task, we are only concerned with the Map.
        });
    }

    private void ShowPayload(IncidentLog incident)
    {
        if (incident == null) return;
        var payload = incident.Evidence?.PayloadBlob ?? Array.Empty<byte>();
        _payloadInspector.Open(payload);
    }

    private async Task LoadHistoricalCountryCounts()
    {
        try
        {
            using var db = DbFactory.CreateDbContext();
            
            // Get all country counts from the database
            var countryCounts = await db.IncidentLogs
                .Where(i => !string.IsNullOrEmpty(i.CountryCode))
                .GroupBy(i => i.CountryCode)
                .Select(g => new { CountryCode = g.Key, Count = g.Count() })
                .ToListAsync();
            
            // Populate the dictionary
            _countryCounts.Clear();
            foreach (var item in countryCounts)
            {
                _countryCounts[item.CountryCode] = item.Count;
            }
            
            Console.WriteLine($"Dashboard: Loaded {_countryCounts.Count} countries from database");
            Console.WriteLine($"Dashboard: FR count from DB: {(_countryCounts.ContainsKey("FR") ? _countryCounts["FR"] : 0)}");
            
            // Update the map with the loaded data
            await JS.InvokeVoidAsync("slurpMap2D.updateHeatmap", _countryCounts);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load historical country counts: {ex.Message}");
        }
    }

    private async Task SetTimeRange(string range)
    {
        _currentTimeRange = range;
        await JS.InvokeVoidAsync("slurpTimeline.update", "timelineChart");
        StateHasChanged();
    }

    [JSInvokable]
    public async Task<object> GetChartData()
    {
        var now = DateTime.UtcNow;
        var start = _currentTimeRange switch
        {
            "1H" => now.AddHours(-1),
            "1D" => now.AddDays(-1),
            "1W" => now.AddDays(-7),
            "1M" => now.AddDays(-30),
            _ => now.AddHours(-1)
        };

        using var db = DbFactory.CreateDbContext();
        var incidents = await db.IncidentLogs
            .Where(i => i.Timestamp >= start)
            .OrderBy(i => i.Timestamp)
            .Select(i => new { i.Timestamp, i.ClassifierName })
            .ToListAsync();

        // Calculate bucket duration
        TimeSpan bucketDuration = _currentTimeRange switch
        {
            "1H" => TimeSpan.FromMinutes(1),
            "1D" => TimeSpan.FromMinutes(30),
            "1W" => TimeSpan.FromHours(6),
            "1M" => TimeSpan.FromDays(1),
            _ => TimeSpan.FromMinutes(1)
        };

        // Create buckets
        var buckets = new List<DateTime>();
        // Round start down to nearest bucket
        var bucketStart = new DateTime(start.Ticks - (start.Ticks % bucketDuration.Ticks), start.Kind);
        for (var t = bucketStart; t <= now; t = t.Add(bucketDuration))
        {
            buckets.Add(t);
        }

        var labels = buckets.Select(b => _currentTimeRange switch {
            "1H" => b.ToLocalTime().ToString("HH:mm"),
            "1D" => b.ToLocalTime().ToString("HH:mm"),
            "1W" => b.ToLocalTime().ToString("MM/dd HH:mm"),
            "1M" => b.ToLocalTime().ToString("MM/dd"),
            _ => b.ToLocalTime().ToString("HH:mm")
        }).ToList();

        // Determine Top 8 Classifiers
        var topClassifiers = incidents
            .GroupBy(i => i.ClassifierName)
            .OrderByDescending(g => g.Count())
            .Take(8)
            .Select(g => g.Key)
            .ToList();

        var datasets = new List<object>();
        var palette = new[] { "#33b5e5", "#ff4444", "#ffbb33", "#00C851", "#9933CC", "#2BBBAD", "#ff8800", "#CC0000" };
        
        // Add datasets for Top 8
        for (int i = 0; i < topClassifiers.Count; i++)
        {
            var classifier = topClassifiers[i];
            var color = palette[i % palette.Length];
            var data = new List<int>();

            foreach (var bStart in buckets)
            {
                var bEnd = bStart.Add(bucketDuration);
                var count = incidents.Count(inc => inc.ClassifierName == classifier && inc.Timestamp >= bStart && inc.Timestamp < bEnd);
                data.Add(count);
            }

            datasets.Add(new
            {
                label = classifier,
                data = data,
                backgroundColor = color,
                borderColor = color,
                borderWidth = 1
            });
        }

        // Add "Other" dataset if needed
        var otherCountTotal = incidents.Count(inc => !topClassifiers.Contains(inc.ClassifierName));
        if (otherCountTotal > 0)
        {
            var data = new List<int>();
            foreach (var bStart in buckets)
            {
                var bEnd = bStart.Add(bucketDuration);
                var count = incidents.Count(inc => !topClassifiers.Contains(inc.ClassifierName) && inc.Timestamp >= bStart && inc.Timestamp < bEnd);
                data.Add(count);
            }

            datasets.Add(new
            {
                label = "Other",
                data = data,
                backgroundColor = "#adb5bd",  // Grey
                borderColor = "#adb5bd",
                borderWidth = 1
            });
        }

        return new { labels, datasets };
    }

    public void Dispose()
    {
        Ingestion.OnNewIncident -= OnIncidentReceived;
        _refreshTimer?.Dispose();
    }
}
