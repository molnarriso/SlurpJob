@page "/"
@using SlurpJob.Components
@using SlurpJob.Services
@using SlurpJob.Data
@using SlurpJob.Models
@using Microsoft.EntityFrameworkCore
@inject SlurpJob.Services.IngestionService Ingestion
@inject SlurpJob.Services.FilterService FilterService
@inject IJSRuntime JS
@inject IDbContextFactory<SlurpContext> DbFactory
@implements IDisposable

<PageTitle>SlurpJob</PageTitle>

<div class="dashboard-container">
    <div class="dashboard-header">
        <div class="brand">SLURPJOB</div>
        <a href="https://github.com/molnarriso/SlurpJob" target="_blank" class="github-link">GITHUB</a>
    </div>
    
    <!-- Unified Filter Bar -->
    <FilterBar />

    <div class="dashboard-top">
        <div class="map-wrapper">
             <canvas id="mapViz"></canvas>
        </div>
        <div class="timeline-wrapper">
             <div class="timeline-controls">
                <button class="@(_currentTimeRange == "1H" ? "active" : "")" @onclick='() => SetTimeRange("1H")'>1H</button>
                <button class="@(_currentTimeRange == "1D" ? "active" : "")" @onclick='() => SetTimeRange("1D")'>1D</button>
                <button class="@(_currentTimeRange == "1W" ? "active" : "")" @onclick='() => SetTimeRange("1W")'>1W</button>
                <button class="@(_currentTimeRange == "1M" ? "active" : "")" @onclick='() => SetTimeRange("1M")'>1M</button>
             </div>

             <div class="custom-legend">
                @foreach (var item in _legendItems)
                {
                    <div class="legend-pill" 
                         style="--hover-color: @item.Color; cursor: pointer;"
                         @onclick="() => OnClassifierClicked(item.Name)">
                        <span class="legend-indicator" style="background-color: @item.Color"></span>
                        <span class="legend-label">@item.Name</span>
                        <span class="legend-count"> | @item.Count.ToString("N0")</span>
                    </div>
                }
             </div>

             <canvas id="timelineChart"></canvas>
        </div>
    </div>

    <div class="dashboard-bottom">
         <LiveFeed OnEventSelected="ShowPayload" />
    </div>
</div>

<PayloadInspector @ref="_payloadInspector" />

@code {
    private PayloadInspector _payloadInspector = default!;
    private System.Threading.Timer? _refreshTimer;
    private Dictionary<string, int> _countryCounts = new();
    private string _currentTimeRange = "1H";

    public class LegendItem {
        public string Name { get; set; } = "";
        public string Color { get; set; } = "";
        public int Count { get; set; }
    }

    private List<LegendItem> _legendItems = new();

    private List<string> _currentTopClassifiers = new(); // Tracked to handle "Other" logic

    protected override void OnInitialized()
    {
        Ingestion.OnNewIncident += OnIncidentReceived;
        FilterService.OnFiltersChanged += OnFiltersChanged;
    }
    
    // Handler for FilterService events
    private async void OnFiltersChanged()
    {
        await InvokeAsync(async () => 
        {
             await LoadHistoricalCountryCounts();
             await JS.InvokeVoidAsync("slurpTimeline.update", "timelineChart");
             // Add any specific visual updates here
             StateHasChanged();
        });
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try {
                // Initialize Globe and Timeline
                // Use catch to ensure one failure doesn't stop the other
                try { await JS.InvokeVoidAsync("slurpMap2D.init", "mapViz", DotNetObjectReference.Create(this)); } catch(Exception ex) { Console.WriteLine("Map2D Init: " + ex.Message); }
                try { await JS.InvokeVoidAsync("slurpTimeline.init", "timelineChart", DotNetObjectReference.Create(this)); } catch(Exception ex) { Console.WriteLine("Timeline Init: " + ex.Message); }
                
                // Load historical country counts from database
                await LoadHistoricalCountryCounts();
            } catch (Exception ex) {
                Console.WriteLine("JS Init Failed: " + ex.Message);
            }
            
            // Start Refresh Timer for stats and timeline
            _refreshTimer = new System.Threading.Timer(async _ => 
            {
                await InvokeAsync(StateHasChanged);
                try {
                    await JS.InvokeVoidAsync("slurpTimeline.update", "timelineChart");
                    // Ensure visuals persist after update
                    await UpdateVisuals(); // Push state again just in case chart reset
                } catch { }
            }, null, 1000, 5000); // Update timeline every 5s
        }
    }

    private void OnIncidentReceived(IncidentLog incident)
    {
        if (string.IsNullOrEmpty(incident.CountryCode)) return;

        // Apply Global Filters (in-memory)
        if (!FilterService.MatchesAll(incident)) return;

        InvokeAsync(async () =>
        {
            if (!_countryCounts.ContainsKey(incident.CountryCode))
            {
                _countryCounts[incident.CountryCode] = 0;
            }
            _countryCounts[incident.CountryCode]++;

            try
            {
                await JS.InvokeVoidAsync("slurpMap2D.updateHeatmap", _countryCounts);
                
                // Trigger blink effect
                await JS.InvokeVoidAsync("slurpMap2D.triggerBlink", incident.CountryCode);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Map Update Error: {ex.Message}");
            }
        });
    }

    private void ShowPayload(IncidentLog incident)
    {
        if (incident == null) return;
        _payloadInspector.Open(incident);
    }

    private async Task LoadHistoricalCountryCounts()
    {
        try
        {
            using var db = DbFactory.CreateDbContext();
            
            // Build Query with Global Filters
            var query = db.IncidentLogs.Where(i => !string.IsNullOrEmpty(i.CountryCode));
            query = FilterService.ApplyAll(query); // <-- MAGIC
            
            var countryCounts = await query
                .GroupBy(i => i.CountryCode)
                .Select(g => new { CountryCode = g.Key, Count = g.Count() })
                .ToListAsync();
            
            _countryCounts.Clear();
            foreach (var item in countryCounts)
            {
                _countryCounts[item.CountryCode] = item.Count;
            }
            
            await JS.InvokeVoidAsync("slurpMap2D.updateHeatmap", _countryCounts);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load historical country counts: {ex.Message}");
        }
    }

    private async Task SetTimeRange(string range)
    {
        _currentTimeRange = range;
        await JS.InvokeVoidAsync("slurpTimeline.update", "timelineChart");
        StateHasChanged();
    }

    [JSInvokable]
    public void OnClassifierClicked(string classifierName)
    {
        // Check if already exists to avoid duplicates? FilterService could handle that, but for now just add
        FilterService.AddFilter(new ClassifierFilter(classifierName));
    }

    [JSInvokable]
    public void OnCountryClicked(string isoCode)
    {
        // Try to find full name? Only code is available from map click easily
        FilterService.AddFilter(new CountryFilter(isoCode, ""));
    }

    private async Task UpdateVisuals()
    {
        // No-op for now in unified version
        // Logic moved to data-driven re-renders via OnFiltersChanged
        await Task.CompletedTask;
    }

    [JSInvokable]
    public async Task<object> GetChartData()
    {
        var now = DateTime.UtcNow;
        var start = _currentTimeRange switch
        {
            "1H" => now.AddHours(-1),
            "1D" => now.AddDays(-1),
            "1W" => now.AddDays(-7),
            "1M" => now.AddDays(-30),
            _ => now.AddHours(-1)
        };

        using var db = DbFactory.CreateDbContext();
        
        var query = db.IncidentLogs.Where(i => i.Timestamp >= start);
        query = FilterService.ApplyAll(query); // <-- MAGIC

        var incidents = await query
            .OrderBy(i => i.Timestamp)
            .Select(i => new { i.Timestamp, i.ClassifierName })
            .ToListAsync();

        // Calculate bucket duration
        TimeSpan bucketDuration = _currentTimeRange switch
        {
            "1H" => TimeSpan.FromMinutes(1),
            "1D" => TimeSpan.FromMinutes(30),
            "1W" => TimeSpan.FromHours(6),
            "1M" => TimeSpan.FromDays(1),
            _ => TimeSpan.FromMinutes(1)
        };

        // Create buckets
        var buckets = new List<DateTime>();
        var bucketStart = new DateTime(start.Ticks - (start.Ticks % bucketDuration.Ticks), start.Kind);
        for (var t = bucketStart; t <= now; t = t.Add(bucketDuration)) buckets.Add(t);

        var labels = buckets.Select(b => _currentTimeRange switch {
            "1H" => b.ToLocalTime().ToString("HH:mm"),
            "1D" => b.ToLocalTime().ToString("HH:mm"),
            "1W" => b.ToLocalTime().ToString("MM/dd HH:mm"),
            "1M" => b.ToLocalTime().ToString("MM/dd"),
            _ => b.ToLocalTime().ToString("HH:mm")
        }).ToList();

        // Determine Top 8 Classifiers
        var topClassifiers = incidents
            .GroupBy(i => i.ClassifierName)
            .OrderByDescending(g => g.Count())
            .Take(8)
            .Select(g => g.Key)
            .ToList();
            
        _currentTopClassifiers = topClassifiers; // Update tracked list

        var datasets = new List<object>();
        var palette = new[] { "#33b5e5", "#ff4444", "#ffbb33", "#00C851", "#9933CC", "#2BBBAD", "#ff8800", "#CC0000" };
        
        var newLegendItems = new List<LegendItem>();

        for (int i = 0; i < topClassifiers.Count; i++)
        {
            var classifier = topClassifiers[i];
            var color = palette[i % palette.Length];
            var data = new List<int>();

            int totalForClassifier = 0;
            foreach (var bStart in buckets)
            {
                var bEnd = bStart.Add(bucketDuration);
                var count = incidents.Where(inc => inc.ClassifierName == classifier && inc.Timestamp >= bStart && inc.Timestamp < bEnd).Count();
                data.Add(count);
                totalForClassifier += count;
            }

            datasets.Add(new { label = classifier, data = data, backgroundColor = color, borderColor = color, borderWidth = 1 });
            newLegendItems.Add(new LegendItem { Name = classifier, Color = color, Count = totalForClassifier });
        }

        var otherIncidents = incidents.Where(inc => !topClassifiers.Contains(inc.ClassifierName)).ToList();
        if (otherIncidents.Count > 0)
        {
            var data = new List<int>();
            foreach (var bStart in buckets)
            {
                var bEnd = bStart.Add(bucketDuration);
                var count = otherIncidents.Count(inc => inc.Timestamp >= bStart && inc.Timestamp < bEnd);
                data.Add(count);
            }
            datasets.Add(new { label = "Other", data = data, backgroundColor = "#adb5bd", borderColor = "#adb5bd", borderWidth = 1 });
            newLegendItems.Add(new LegendItem { Name = "Other", Color = "#adb5bd", Count = otherIncidents.Count });
        }

        _legendItems = newLegendItems;
        await InvokeAsync(StateHasChanged);

        return new { labels, datasets };
    }



    public void Dispose()
    {
        Ingestion.OnNewIncident -= OnIncidentReceived;
        FilterService.OnFiltersChanged -= OnFiltersChanged;
        _refreshTimer?.Dispose();
    }
}
