@page "/"
@using SlurpJob.Components
@using SlurpJob.Services
@using SlurpJob.Data
@using SlurpJob.Models
@using Microsoft.EntityFrameworkCore
@inject SlurpJob.Services.IngestionService Ingestion
@inject IJSRuntime JS
@inject IDbContextFactory<SlurpContext> DbFactory
@implements IDisposable

<PageTitle>SlurpJob</PageTitle>

<div class="dashboard-container">
    <div class="dashboard-header">
        <div class="brand">SLURPJOB</div>
        <a href="https://github.com/molnarriso/SlurpJob" target="_blank" class="github-link">GITHUB</a>
    </div>

    <div class="dashboard-top">
        <div class="map-wrapper">
             <canvas id="mapViz"></canvas>
        </div>
        <div class="timeline-wrapper">
             <div class="timeline-controls">
                <button class="@(_currentTimeRange == "1H" ? "active" : "")" @onclick='() => SetTimeRange("1H")'>1H</button>
                <button class="@(_currentTimeRange == "1D" ? "active" : "")" @onclick='() => SetTimeRange("1D")'>1D</button>
                <button class="@(_currentTimeRange == "1W" ? "active" : "")" @onclick='() => SetTimeRange("1W")'>1W</button>
                <button class="@(_currentTimeRange == "1M" ? "active" : "")" @onclick='() => SetTimeRange("1M")'>1M</button>
             </div>

             <div class="custom-legend">
                @foreach (var item in _legendItems)
                {
                    <div class="legend-pill @(GetLegendStatusClass(item.Name))" 
                         style="--hover-color: @item.Color"
                         @onclick="() => OnClassifierClicked(item.Name)">
                        <span class="legend-indicator" style="background-color: @item.Color"></span>
                        <span class="legend-label">@item.Name</span>
                        <span class="legend-count"> | @item.Count.ToString("N0")</span>
                    </div>
                }
             </div>

             <canvas id="timelineChart"></canvas>
        </div>
    </div>

    <div class="dashboard-bottom">
         <LiveFeed OnEventSelected="ShowPayload" />
    </div>
</div>

<PayloadInspector @ref="_payloadInspector" />

@code {
    private PayloadInspector _payloadInspector = default!;
    private System.Threading.Timer? _refreshTimer;
    private Dictionary<string, int> _countryCounts = new();
    private string _currentTimeRange = "1H";

    public class LegendItem {
        public string Name { get; set; } = "";
        public string Color { get; set; } = "";
        public int Count { get; set; }
    }

    private List<LegendItem> _legendItems = new();

    // Centralized Filter State
    private enum FilterMode { None, Exclusive, Filtered }
    private class FilterState {
        public string? SelectedKey { get; set; }
        public FilterMode Mode { get; set; } = FilterMode.None;
    }

    private FilterState _classifierFilter = new();
    private FilterState _countryFilter = new();
    private List<string> _currentTopClassifiers = new(); // Tracked to handle "Other" logic

    protected override void OnInitialized()
    {
        Ingestion.OnNewIncident += OnIncidentReceived;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try {
                // Initialize Globe and Timeline
                // Use catch to ensure one failure doesn't stop the other
                try { await JS.InvokeVoidAsync("slurpMap2D.init", "mapViz", DotNetObjectReference.Create(this)); } catch(Exception ex) { Console.WriteLine("Map2D Init: " + ex.Message); }
                try { await JS.InvokeVoidAsync("slurpTimeline.init", "timelineChart", DotNetObjectReference.Create(this)); } catch(Exception ex) { Console.WriteLine("Timeline Init: " + ex.Message); }
                
                // Load historical country counts from database
                await LoadHistoricalCountryCounts();
            } catch (Exception ex) {
                Console.WriteLine("JS Init Failed: " + ex.Message);
            }
            
            // Start Refresh Timer for stats and timeline
            _refreshTimer = new System.Threading.Timer(async _ => 
            {
                await InvokeAsync(StateHasChanged);
                try {
                    await JS.InvokeVoidAsync("slurpTimeline.update", "timelineChart");
                    // Ensure visuals persist after update
                    await UpdateVisuals(); // Push state again just in case chart reset
                } catch { }
            }, null, 1000, 5000); // Update timeline every 5s
        }
    }

    private void OnIncidentReceived(IncidentLog incident)
    {
        if (string.IsNullOrEmpty(incident.CountryCode)) return;

        // Apply Classifier Filter to Map Data
        bool matchesClassifier = _classifierFilter.Mode == FilterMode.None;
        if (_classifierFilter.Mode == FilterMode.Exclusive)
        {
            if (_classifierFilter.SelectedKey == "Other") matchesClassifier = !_currentTopClassifiers.Contains(incident.ClassifierName);
            else matchesClassifier = incident.ClassifierName == _classifierFilter.SelectedKey;
        }
        else if (_classifierFilter.Mode == FilterMode.Filtered)
        {
             if (_classifierFilter.SelectedKey == "Other") matchesClassifier = _currentTopClassifiers.Contains(incident.ClassifierName);
             else matchesClassifier = incident.ClassifierName != _classifierFilter.SelectedKey;
        }

        if (!matchesClassifier) return;

        InvokeAsync(async () =>
        {
            if (!_countryCounts.ContainsKey(incident.CountryCode))
            {
                _countryCounts[incident.CountryCode] = 0;
            }
            _countryCounts[incident.CountryCode]++;

            try
            {
                // We just send data updates. Visual state (dimming) is handled by the client's current state (or re-pushed if needed)
                // Actually map2d.js keeps state, but better to be stateless?
                // For now, map2d will hold the visual state until we push an update. 
                // But wait, if we filter OUT data here, then the map gets 0 for that country or just doesn't increment?
                // If we filter logic here, we prevent the count from increasing in memory.
                
                // WAIT. If we filter specific attacks, the TOTAL count for a country should reflect that filter.
                // So yes, we should only increment if it matches the filter.
                // AND we need to push the new numbers.
                
                await JS.InvokeVoidAsync("slurpMap2D.updateHeatmap", _countryCounts);
                
                // Trigger blink effect
                await JS.InvokeVoidAsync("slurpMap2D.triggerBlink", incident.CountryCode);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Map Update Error: {ex.Message}");
            }
        });
    }

    private void ShowPayload(IncidentLog incident)
    {
        if (incident == null) return;
        _payloadInspector.Open(incident);
    }

    private async Task LoadHistoricalCountryCounts()
    {
        try
        {
            using var db = DbFactory.CreateDbContext();
            
            // Build Query with Classifier Filter
            var query = db.IncidentLogs.Where(i => !string.IsNullOrEmpty(i.CountryCode));

            if (_classifierFilter.Mode == FilterMode.Exclusive)
            {
                if (_classifierFilter.SelectedKey == "Other")
                    query = query.Where(i => !_currentTopClassifiers.Contains(i.ClassifierName));
                else
                   query = query.Where(i => i.ClassifierName == _classifierFilter.SelectedKey);
            }
            else if (_classifierFilter.Mode == FilterMode.Filtered)
            {
                if (_classifierFilter.SelectedKey == "Other")
                     query = query.Where(i => _currentTopClassifiers.Contains(i.ClassifierName));
                else
                    query = query.Where(i => i.ClassifierName != _classifierFilter.SelectedKey);
            }
            
            var countryCounts = await query
                .GroupBy(i => i.CountryCode)
                .Select(g => new { CountryCode = g.Key, Count = g.Count() })
                .ToListAsync();
            
            _countryCounts.Clear();
            foreach (var item in countryCounts)
            {
                _countryCounts[item.CountryCode] = item.Count;
            }
            
            await JS.InvokeVoidAsync("slurpMap2D.updateHeatmap", _countryCounts);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load historical country counts: {ex.Message}");
        }
    }

    private async Task SetTimeRange(string range)
    {
        _currentTimeRange = range;
        await JS.InvokeVoidAsync("slurpTimeline.update", "timelineChart");
        StateHasChanged();
    }

    [JSInvokable]
    public async Task OnClassifierClicked(string classifierName)
    {
        // Mutually Exclusive: Reset Country Filter
        if (_countryFilter.Mode != FilterMode.None)
        {
            _countryFilter = new FilterState();
        }

        // Cycle State: None -> Exclusive -> Filtered -> None
        // Switching Category: -> Exclusive
        
        if (_classifierFilter.SelectedKey != classifierName)
        {
            _classifierFilter.SelectedKey = classifierName;
            _classifierFilter.Mode = FilterMode.Exclusive;
        }
        else
        {
            _classifierFilter.Mode = _classifierFilter.Mode switch
            {
                FilterMode.None => FilterMode.Exclusive,
                FilterMode.Exclusive => FilterMode.Filtered,
                FilterMode.Filtered => FilterMode.None,
                _ => FilterMode.None
            };
            
            if (_classifierFilter.Mode == FilterMode.None) _classifierFilter.SelectedKey = null;
        }

        // 1. Update Map Data (Historical + Live logic)
        await LoadHistoricalCountryCounts();
        
        // 2. Update Visuals (Push to JS)
        await UpdateVisuals();
    }

    [JSInvokable]
    public async Task OnCountryClicked(string isoCode)
    {
        // Mutually Exclusive: Reset Classifier Filter
        if (_classifierFilter.Mode != FilterMode.None)
        {
            _classifierFilter = new FilterState();
            // We must reload historical counts to show ALL classifiers again for the new country selection
            // Actually LoadHistoricalCountryCounts depends on ClassifierFilter, so resetting it affects map data too?
            // Wait. LoadHistoricalCountryCounts uses _classifierFilter to filter the MAP DATA.
            // If we reset _classifierFilter, we should reload map data?
            // Yes, "LoadHistoricalCountryCounts" reloads the map counts based on the current classifier filter.
            // So if we clear classifier filter, we expect map to show all attacks (filtered by country visually? No, map data is total counts).
            // Actually, LoadHistoricalCountryCounts updates `_countryCounts`.
            await LoadHistoricalCountryCounts();
        }

        if (_countryFilter.SelectedKey != isoCode)
        {
            _countryFilter.SelectedKey = isoCode;
            _countryFilter.Mode = FilterMode.Exclusive;
        }
        else
        {
            _countryFilter.Mode = _countryFilter.Mode switch
            {
                FilterMode.None => FilterMode.Exclusive,
                FilterMode.Exclusive => FilterMode.Filtered,
                FilterMode.Filtered => FilterMode.None,
                _ => FilterMode.None
            };
             if (_countryFilter.Mode == FilterMode.None) _countryFilter.SelectedKey = null;
        }

        // 1. Update Timeline Data (GetChartData will handle this on next update)
        await JS.InvokeVoidAsync("slurpTimeline.update", "timelineChart"); // Pulls new data
        
        // 2. Update Visuals
        await UpdateVisuals();
    }

    private async Task UpdateVisuals()
    {
        // Calculate Timeline Visuals (Hidden Labels)
        var timelineHidden = new List<string>();
        // Note: Timeline handles hiding visually separately from data filtering?
        // Wait, current timeline.js hides datasets. 
        // If we filter by Country, the data changes.
        // If we filter by Classifier, the visuals change (hide bars).
        
        // Classifier Logic for Timeline Visuals
        if (_classifierFilter.Mode == FilterMode.Exclusive && _classifierFilter.SelectedKey != null)
        {
            // Hide everything except Selected
            // We need to know all categories. _currentTopClassifiers + "Other"
            var all = new List<string>(_currentTopClassifiers); 
            // We can't know if "Other" exists here easily without data, but reasonable guess
            all.Add("Other");
            
            foreach (var c in all) if (c != _classifierFilter.SelectedKey) timelineHidden.Add(c);
        }
        else if (_classifierFilter.Mode == FilterMode.Filtered && _classifierFilter.SelectedKey != null)
        {
            timelineHidden.Add(_classifierFilter.SelectedKey);
        }
        
        // Calculate Map Visuals
        object mapVisuals = new { 
            activeCountry = _countryFilter.SelectedKey, 
            mode = _countryFilter.Mode.ToString() 
        };

        var visuals = new {
            timeline = timelineHidden,
            map = mapVisuals
        };

        await JS.InvokeVoidAsync("slurp.updateVisuals", visuals);
    }

    [JSInvokable]
    public async Task<object> GetChartData()
    {
        var now = DateTime.UtcNow;
        var start = _currentTimeRange switch
        {
            "1H" => now.AddHours(-1),
            "1D" => now.AddDays(-1),
            "1W" => now.AddDays(-7),
            "1M" => now.AddDays(-30),
            _ => now.AddHours(-1)
        };

        using var db = DbFactory.CreateDbContext();
        
        // Apply Country Filter
        var query = db.IncidentLogs.Where(i => i.Timestamp >= start);
        
        if (_countryFilter.Mode == FilterMode.Exclusive && _countryFilter.SelectedKey != null)
        {
            query = query.Where(i => i.CountryCode == _countryFilter.SelectedKey);
        }
        else if (_countryFilter.Mode == FilterMode.Filtered && _countryFilter.SelectedKey != null)
        {
            query = query.Where(i => i.CountryCode != _countryFilter.SelectedKey);
        }

        var incidents = await query
            .OrderBy(i => i.Timestamp)
            .Select(i => new { i.Timestamp, i.ClassifierName })
            .ToListAsync();

        // Calculate bucket duration
        TimeSpan bucketDuration = _currentTimeRange switch
        {
            "1H" => TimeSpan.FromMinutes(1),
            "1D" => TimeSpan.FromMinutes(30),
            "1W" => TimeSpan.FromHours(6),
            "1M" => TimeSpan.FromDays(1),
            _ => TimeSpan.FromMinutes(1)
        };

        // Create buckets
        var buckets = new List<DateTime>();
        var bucketStart = new DateTime(start.Ticks - (start.Ticks % bucketDuration.Ticks), start.Kind);
        for (var t = bucketStart; t <= now; t = t.Add(bucketDuration)) buckets.Add(t);

        var labels = buckets.Select(b => _currentTimeRange switch {
            "1H" => b.ToLocalTime().ToString("HH:mm"),
            "1D" => b.ToLocalTime().ToString("HH:mm"),
            "1W" => b.ToLocalTime().ToString("MM/dd HH:mm"),
            "1M" => b.ToLocalTime().ToString("MM/dd"),
            _ => b.ToLocalTime().ToString("HH:mm")
        }).ToList();

        // Determine Top 8 Classifiers
        var topClassifiers = incidents
            .GroupBy(i => i.ClassifierName)
            .OrderByDescending(g => g.Count())
            .Take(8)
            .Select(g => g.Key)
            .ToList();
            
        _currentTopClassifiers = topClassifiers; // Update tracked list

        var datasets = new List<object>();
        var palette = new[] { "#33b5e5", "#ff4444", "#ffbb33", "#00C851", "#9933CC", "#2BBBAD", "#ff8800", "#CC0000" };
        
        var newLegendItems = new List<LegendItem>();

        for (int i = 0; i < topClassifiers.Count; i++)
        {
            var classifier = topClassifiers[i];
            var color = palette[i % palette.Length];
            var data = new List<int>();

            int totalForClassifier = 0;
            foreach (var bStart in buckets)
            {
                var bEnd = bStart.Add(bucketDuration);
                var count = incidents.Where(inc => inc.ClassifierName == classifier && inc.Timestamp >= bStart && inc.Timestamp < bEnd).Count();
                data.Add(count);
                totalForClassifier += count;
            }

            datasets.Add(new { label = classifier, data = data, backgroundColor = color, borderColor = color, borderWidth = 1 });
            newLegendItems.Add(new LegendItem { Name = classifier, Color = color, Count = totalForClassifier });
        }

        var otherIncidents = incidents.Where(inc => !topClassifiers.Contains(inc.ClassifierName)).ToList();
        if (otherIncidents.Count > 0)
        {
            var data = new List<int>();
            foreach (var bStart in buckets)
            {
                var bEnd = bStart.Add(bucketDuration);
                var count = otherIncidents.Count(inc => inc.Timestamp >= bStart && inc.Timestamp < bEnd);
                data.Add(count);
            }
            datasets.Add(new { label = "Other", data = data, backgroundColor = "#adb5bd", borderColor = "#adb5bd", borderWidth = 1 });
            newLegendItems.Add(new LegendItem { Name = "Other", Color = "#adb5bd", Count = otherIncidents.Count });
        }

        _legendItems = newLegendItems;
        await InvokeAsync(StateHasChanged);

        return new { labels, datasets };
    }

    private string GetLegendStatusClass(string name)
    {
        if (_classifierFilter.Mode == FilterMode.None) return "";
        if (_classifierFilter.SelectedKey == name)
        {
            return _classifierFilter.Mode == FilterMode.Exclusive ? "selective" : "filtered";
        }
        return _classifierFilter.Mode == FilterMode.Exclusive ? "dimmed" : "";
    }

    public void Dispose()
    {
        Ingestion.OnNewIncident -= OnIncidentReceived;
        _refreshTimer?.Dispose();
    }
}
