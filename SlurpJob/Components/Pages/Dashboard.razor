@page "/"
@using SlurpJob.Components
@using SlurpJob.Services
@using SlurpJob.Data
@using SlurpJob.Models
@inject SlurpJob.Services.IngestionService Ingestion
@inject IJSRuntime JS
@implements IDisposable

<PageTitle>Dashboard</PageTitle>

<div class="dashboard-container">
    <div class="dashboard-header">
        <div class="brand">SLURPJOB</div>
        <div class="stats">
            <div class="stat-item">
                <span class="label">EVENTS</span>
                <span class="value">@Ingestion.TotalEvents.ToString("N0")</span>
            </div>
            <div class="stat-item">
                <span class="label">THREATS</span>
                <span class="value" style="color: #ff4444">@Ingestion.ThreatsDetected.ToString("N0")</span>
            </div>
             <div class="stat-item">
                <span class="label">CPS</span>
                <span class="value">@((int)Ingestion.EventsPerSecond)</span>
            </div>
        </div>
    </div>

    <div class="dashboard-top">
        <div class="map-wrapper">
             <canvas id="mapViz"></canvas>
        </div>
        <div class="timeline-wrapper">
             <canvas id="timelineChart"></canvas>
        </div>
    </div>

    <div class="dashboard-bottom">
         <LiveFeed OnEventSelected="ShowPayload" />
    </div>
</div>

<PayloadInspector @ref="_payloadInspector" />

@code {
    private PayloadInspector _payloadInspector = default!;
    private System.Threading.Timer? _refreshTimer;
    private Dictionary<string, int> _countryCounts = new();

    protected override void OnInitialized()
    {
        Ingestion.OnNewIncident += OnIncidentReceived;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try {
                // Initialize Globe and Timeline
                // Use catch to ensure one failure doesn't stop the other
                try { await JS.InvokeVoidAsync("slurpMap2D.init", "mapViz"); } catch(Exception ex) { Console.WriteLine("Map2D Init: " + ex.Message); }
                try { await JS.InvokeVoidAsync("slurpTimeline.init", "timelineChart", DotNetObjectReference.Create(this)); } catch(Exception ex) { Console.WriteLine("Timeline Init: " + ex.Message); }
            } catch (Exception ex) {
                Console.WriteLine("JS Init Failed: " + ex.Message);
            }
            
            // Start Refresh Timer for stats
            _refreshTimer = new System.Threading.Timer(_ =>InvokeAsync(StateHasChanged), null, 1000, 1000);
        }
    }

    private void OnIncidentReceived(IncidentLog incident)
    {
        if (string.IsNullOrEmpty(incident.CountryCode)) return;

        InvokeAsync(async () =>
        {
            if (!_countryCounts.ContainsKey(incident.CountryCode))
            {
                _countryCounts[incident.CountryCode] = 0;
            }
            _countryCounts[incident.CountryCode]++;

            // Push update to the map
            // We use Fire-and-Forget for performance, or await if we want to ensure order.
            // Since this runs within InvokeAsync, awaiting is fine.
            try
            {
                await JS.InvokeVoidAsync("slurpMap2D.updateHeatmap", _countryCounts);
            }
            catch (Exception ex)
            {
                // If the user navigates away, JS interop might fail.
                Console.WriteLine($"Map Update Error: {ex.Message}");
            }
            
            // Note: We don't call StateHasChanged here for every single packet to avoid UI thrashing.
            // The stats counters are updated by the _refreshTimer every 1s.
            // The LiveFeed component handles its own updates via its own subscription if needed, 
            // or if it binds to a list that updates. 
            // (Assuming LiveFeed has its own logic or receives this event).
            // Actually, looking at LiveFeed usage: <LiveFeed OnEventSelected="ShowPayload" />
            // It seems LiveFeed might handle its own data fetching. 
            // But for THIS task, we are only concerned with the Map.
        });
    }

    private void ShowPayload(IncidentLog incident)
    {
        if (incident == null) return;
        var payload = incident.Evidence?.PayloadBlob ?? Array.Empty<byte>();
        _payloadInspector.Open(payload);
    }

    [JSInvokable]
    public async Task<object> GetChartData()
    {
        return new { };
    }

    public void Dispose()
    {
        Ingestion.OnNewIncident -= OnIncidentReceived;
        _refreshTimer?.Dispose();
    }
}
